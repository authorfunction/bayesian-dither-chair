<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>threejs-bayesian-generation</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Generative Shader</title>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <!-- The canvas element where the shader will be rendered -->
    <canvas id="shader-canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>

    <script>
      async function main() {
        //globals
        let isGlitchActive = true;
        let currentIndex = 0;

        try {
          // --- setup code ---
          const canvas = document.getElementById("shader-canvas");
          const scene = new THREE.Scene();
          const clock = new THREE.Clock();
          const frustumHeight = 2;
          const aspect = canvas.clientWidth / canvas.clientHeight;
          const frustumWidth = frustumHeight * aspect;
          const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
          camera.position.z = 2;
          const renderer = new THREE.WebGLRenderer({ canvas: canvas });
          const composer = new THREE.EffectComposer(renderer);
          const renderPass = new THREE.RenderPass(scene, camera);
          composer.addPass(renderPass);

          const uniforms = {
            tDiffuse: { value: null },
            u_time: { value: 0.0 },
            u_resolution: { value: new THREE.Vector2(1, 1) },
            u_texture: { value: null },
            u_behaviour: { value: 3.0 }, // 0.0, 1.0, or 3.0 sets the behaviour of the shader
          };
          let chair_mesh;

          // Asynchronously fetch shader files.
          // Promise.all waits for to finish.
          console.log("Fetching shaders...");
          const [vertexResponse, fragmentResponse, postResponse] =
            await Promise.all([
              fetch("./vertex_shader.glsl"),
              fetch("./fragment_shader_chromatic.glsl"),
              fetch("./fragment_post_chromatic.glsl"),
            ]);

          // Check if the files were found
          if (!vertexResponse.ok)
            throw new Error(
              `Failed to fetch vertex_shader.glsl: ${vertexResponse.statusText}`,
            );
          if (!fragmentResponse.ok)
            throw new Error(
              `Failed to fetch fragment_shader.glsl: ${fragmentResponse.statusText}`,
            );
          if (!postResponse.ok)
            throw new Error(
              `Failed to fetch fragment_post_chromatic.glsl: ${fragmentPostResponse.statusText}`,
            );

          // Get the text content from the loaded files
          const vertexShader = await vertexResponse.text();
          const fragmentShader = await fragmentResponse.text();
          const postFragmentShader = await postResponse.text();
          console.log("Shaders loaded successfully.");

          // DEFINE THE POST-PROCESSING SHADER OBJECT
          // We need a simple vertex shader for the screen quad.
          // We can define it right here as a string because it never changes.
          const ChromaticAberrationShader = {
            uniforms: {
              tDiffuse: { value: null }, // The screen texture
              u_time: { value: 0.0 },
            },
            // Standard vertex shader for post-processing (just renders a flat square)
            vertexShader: `
                  varying vec2 vUv;
                  void main() {
                      vUv = uv;
                      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                  }
              `,
            // The fragment shader  loaded from the file
            fragmentShader: postFragmentShader,
          };

          // we got all shaders including postprocessing one with definition, we can now add the clean Aberration Pass
          // Add the clean Aberration Pass
          const aberrationPass = new THREE.ShaderPass(
            ChromaticAberrationShader,
          );
          composer.addPass(aberrationPass);

          // NOW create the material, since we have the shader text loaded
          const shader_material = new THREE.ShaderMaterial({
            vertexShader: vertexShader, // <-- Use the loaded text
            fragmentShader: fragmentShader, // <-- Use the loaded text
            uniforms: uniforms,
          });

          // This code can now run because 'shader_material' exists
          const loader = new THREE.GLTFLoader();
          loader.load(
            "Stol.glb",
            function (gltf) {
              console.log("Model loaded successfully!");
              chair_mesh = gltf.scene;

              chair_mesh.traverse(function (child) {
                if (child.isMesh) {
                  child.material = shader_material;
                }
              });

              chair_mesh.scale.set(0.3, 0.3, 0.3);
              scene.add(chair_mesh);
            },
            function (xhr) {
              console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
            },
            function (error) {
              console.error(
                "An error happened while loading the model:",
                error,
              );
            },
          );

          // --- plane geometry code ---
          const plane_geometry = new THREE.PlaneGeometry(1, 2, 8, 8);
          const mesh = new THREE.Mesh(plane_geometry, shader_material);
          mesh.position.z = -2;
          scene.add(mesh);

          window.addEventListener("keydown", function (event) {
            // Check if the key pressed is Space (' ') or  'g' to toggle aberration pass
            if (event.key === " " || event.key === "g") {
              // Flip the boolean
              isGlitchActive = !isGlitchActive;
              console.log("Glitch Active:", isGlitchActive);
            }
            // 'c' key cycles behaviour of the fragment shader
            if (event.key === "c") {
              // step u_behaviour
              const behaviourValues = [3.0, 1.0, 0.0];
              currentIndex = (currentIndex + 1) % behaviourValues.length;
              const newValue = behaviourValues[currentIndex];
              console.log("Behaviour:", newValue);
              uniforms.u_behaviour.value = newValue;
            }
          });

          //const behaviourValues = [3.0, 1.0, 0.0];

          // --- Your original resize handler ---
          function handleResize() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            renderer.setSize(width, height, false);

            const aspect = width / height;
            const frustumHeight = 2;
            const frustumWidth = frustumHeight * aspect;

            camera.left = frustumWidth / -2;
            camera.right = frustumWidth / 2;
            camera.top = frustumHeight / 2;
            camera.bottom = frustumHeight / -2;
            camera.updateProjectionMatrix();
          }
          window.addEventListener("resize", handleResize);
          handleResize();

          // --- Your original animation loop ---
          function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            uniforms.u_time.value = time;

            if (chair_mesh) {
              chair_mesh.rotation.x = time / 10;
              chair_mesh.rotation.y = time / 5;
              chair_mesh.position.y = Math.sin(time) * 0.6;
            }

            // Update time
            aberrationPass.uniforms.u_time.value = performance.now() / 1000;

            if (isGlitchActive) {
              // EITHER RENDER WITH COMPOSER EFFECT PASS:
              composer.render();
            } else {
              // OR WITHOUT:
              renderer.render(scene, camera);
            }
          }

          // --- Start the animation loop ---
          animate();
        } catch (error) {
          // This will catch any errors, like missing files
          console.error("An error occurred:", error);
        }
      }

      // --- Call the main function to start everything ---
      main();
    </script>
  </body>
</html>
