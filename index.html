<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>threejs-bayesian-generation</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Generative Shader</title>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <!-- The canvas element where the shader will be rendered -->
    <canvas id="shader-canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script id="vertexShader-passthrough" type="x-shader/x-vertex">
      // 'varying' means it passes data to the fragment shader
      varying vec2 vUv;
      uniform sampler2D u_texture; // <-- 1. Declare the new uniform

      void main() {
          // 'uv' is an attribute provided by PlaneGeometry
          vUv = uv;

          // 'position' is an attribute.
          // 'projectionMatrix' and 'modelViewMatrix' are uniforms
          // automatically provided by three.js to position the vertex.
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    </script>
    <script id="vertexShader" type="x-shader/x-vertex">
      precision mediump float;
      // 'varying' means it passes data to the fragment shader
      varying vec2 vUv;
      uniform sampler2D u_texture; // <-- 1. Declare the new uniform
      uniform float u_time;

      void main() {
          // 'uv' is an attribute provided by PlaneGeometry
          vUv = uv;
          vec3 displacedPosition = position;
          // 2. Calculate displacement.
          // We use position.x and position.y to make the wave vary across
          // the plane, otherwise the whole plane would just move up and down.
          // Multiplying by 5.0 increases the frequency (more waves).
          // Multiplying by 0.2 decreases the amplitude (smaller waves).
          float displacement =
              sin(position.x * 5.0 + u_time) * 0.2 +
              sin(position.y * 5.0 + u_time) * 0.2;

          // 3. Apply the displacement to the z-axis
          //displacedPosition.z = displacement; // This displacement will be invisible in orthogrpahic straight down view
          // 3. Apply the displacement to the x-axis instead
          displacedPosition.x = position.x + displacement;

        gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
      }
    </script>

    <!-- 3. The Fragment Shader (GLSL) -->
    <!--
      This is where the generative art happens!
      It runs for EVERY pixel on the plane.
    -->
    <script id="fragmentShader" type="x-shader/x-fragment">
        // Set default precision for floating point numbers
        precision mediump float;

        // Uniforms are variables passed from our JavaScript
        uniform vec2 u_resolution; // The resolution of the canvas
        uniform float u_time;       // The elapsed time for animation
        uniform sampler2D u_texture; // <-- 1. Declare the new uniform

        // 'vUv' is the data received from the vertex shader (0.0 to 1.0)
        varying vec2 vUv;

        // --- BAYER DITHERING MAP ---
        // We define the 4x4 Bayer threshold map as a matrix.
        // GLSL matrices are "column-major", so we list the columns.
        const mat4 bayerMap = mat4(
            15.0, 195.0, 60.0, 240.0,  // Column 0
            135.0, 75.0, 180.0, 120.0, // Column 1
            45.0, 225.0, 30.0, 210.0,  // Column 2
            165.0, 105.0, 150.0, 90.0   // Column 3
        );
        // --- END DITHERING MAP ---

      vec3 createColorPattern(vec2 st, float time) {
          float r = sin(st.x * 10.0 + time * 0.5) * 0.5 + 0.5;
          float g = sin(st.y * 10.0 + time * 0.3) * 0.5 + 0.5;
          float b = sin(st.x * 5.0 - st.y * 5.0 + time) * 0.5 + 0.5;
          return vec3(r, g, b);
      }

      float bayesianDither(vec3 originalColor) {
        // 2. CALCULATE LUMINANCE (0.0 to 1.0)
        // Convert the color to grayscale brightness
        //originalColor = color;
        float luminance = dot(originalColor, vec3(0.299, 0.587, 0.114));

        // 3. GET DITHER THRESHOLD
        // gl_FragCoord.xy gives us the screen pixel coordinate (e.g., 800, 600)
        // We use mod() to find which cell in the 4x4 map this pixel corresponds to.
        int x = int(mod(gl_FragCoord.x, 4.0));
        int y = int(mod(gl_FragCoord.y, 4.0));

        // Look up the threshold value from the map (col, row)
        // The value is 0-255, so we divide by 255.0 to normalize it to 0.0-1.0
        float threshold = bayerMap[x][y] / 255.0;

        // 4. COMPARE AND SET FINAL COLOR
        // If the luminance is brighter than the threshold, use 1.0 (bright).
        // Otherwise, use 0.0 (dark).
        float ditheredValue = luminance > threshold ? 1.0 : 0.0;

        return ditheredValue;
        //return 1.0;
      }

        void main() {
            // 'vUv' gives us the normalized coordinate (0.0 to 1.0)
            vec2 st = vUv;

            // 1. CALCULATE ORIGINAL COLOR
            vec3 originalColor = createColorPattern(st, u_time);
            vec3 textureColor = texture2D(u_texture, st).rgb;

            vec3 blendedColor = mix(originalColor, textureColor, 0.5);
            // 2. Apply Bayesian dither
            float ditheredValue = bayesianDither(blendedColor);
            //float ditheredTextureValue = bayesianDither(textureColor);

            // Blend the original color with the dithered value.
            // This preserves the color, but applies the dither pattern
            // (multiplying by 1.0 keeps the color, multiplying by 0.0 makes it black).
            // with texture:
            //vec3 finalColor = blendedColor * ditheredValue;

            float ditheredValue2 = bayesianDither(originalColor);
            vec3 finalColor = originalColor * ditheredValue2;

            // Set the final composited color as periodically bw or colored
            if ((sin(u_time/1.17)) < 0.0 ) {
              gl_FragColor = vec4(finalColor, 1.0); //<= Colorize
            }
            else {
              gl_FragColor = vec4(vec3(ditheredValue2), 1.0);
            }; //<= Monochrome no texture
            //gl_FragColor = vec4(vec3(ditheredValue), 1.0); //<= Monochrome w/ texture
        }
    </script>

    <!-- 4. The JavaScript to set up three.js -->
    <script>
      // Get the canvas element
      const canvas = document.getElementById("shader-canvas");

      // Create the three.js scene
      const scene = new THREE.Scene();

      // Create a clock to track elapsed time
      const clock = new THREE.Clock();

      // We'll use a vertical view size of 2 (from -1 to 1)
      const frustumHeight = 2;
      const aspect = canvas.clientWidth / canvas.clientHeight;
      const frustumWidth = frustumHeight * aspect;

      // Create camera with placeholder bounds, handleResize() will fix it
      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);

      // *** NEW ***
      // Position the camera so it looks at the scene
      camera.position.z = 2;

      // Create the WebGL renderer
      const renderer = new THREE.WebGLRenderer({ canvas: canvas });

      const uniforms = {
        u_time: { value: 0.0 },
        u_resolution: { value: new THREE.Vector2(1, 1) }, // Placeholder
        u_texture: { value: null },
      };

      // Declare the chair variable
      let chair_mesh;

      // Create the material, using our custom shaders and uniforms
      const shader_material = new THREE.ShaderMaterial({
        vertexShader: document.getElementById("vertexShader").textContent,
        fragmentShader: document.getElementById("fragmentShader").textContent,
        uniforms: uniforms,
      });

      // 1. Instantiate the loader
      const loader = new THREE.GLTFLoader();

      // 2. Call the .load() method
      loader.load(
        "Stol.glb",
        function (gltf) {
          // 3. (onLoad) Success callback
          console.log("Model loaded successfully!");

          // Assign the loaded model to our variable
          chair_mesh = gltf.scene;

          // Apply the custom shader material to the loaded model
          chair_mesh.traverse(function (child) {
            if (child.isMesh) {
              child.material = shader_material;
            }
          });

          // *** MODIFIED ***
          // Scale the chair down to fit in the 2x2 orthographic view
          //chair_mesh.scale.set(0.5, 0.5, 0.5);
          // Scale the chair to be much smaller
          chair_mesh.scale.set(0.3, 0.3, 0.3);

          // Add the loaded model to the scene
          scene.add(chair_mesh);
        },
        function (xhr) {
          // 4. (onProgress) Optional progress callback
          console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
        },
        function (error) {
          // 5. (onError) Optional error callback
          console.error("An error happened while loading the model:", error);
        },
      );

      // Create the geometry: a simple plane that fills the screen
      // The 2, 2 dimensions match the orthographic camera's view
      const plane_geometry = new THREE.PlaneGeometry(1, 2, 8, 8);

      // Create a mesh (the 3D object) from the geometry and material
      const mesh = new THREE.Mesh(plane_geometry, shader_material);

      // *** IMPORTANT ***
      // Move the plane back so it's behind the chair
      mesh.position.z = -2;

      // Add the mesh to the scene
      scene.add(mesh);

      // 1. Define ONE function to handle all sizing
      function handleResize() {
        // Get the new size from the CSS-controlled canvas
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;

        // Update renderer resolution, but NOT the style
        renderer.setSize(width, height, false);

        // Update shader resolution uniform -- Not sure this makes a difference, removing it for now
        //uniforms.u_resolution.value.set(width, height);

        // Update camera bounds
        const aspect = width / height;
        const frustumHeight = 2; // Keep vertical size consistent
        const frustumWidth = frustumHeight * aspect;

        camera.left = frustumWidth / -2;
        camera.right = frustumWidth / 2;
        camera.top = frustumHeight / 2;
        camera.bottom = frustumHeight / -2;

        // Tell the camera to apply the changes
        camera.updateProjectionMatrix();
      }

      // 2. Add the listener
      window.addEventListener("resize", handleResize);

      // 3. Call it ONCE right now to set the correct initial size
      handleResize();

      // Create the animation loop
      function animate() {
        // Request the next frame
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // Update the 'u_time' uniform with the elapsed time
        uniforms.u_time.value = time;

        // Check if chair_mesh has been loaded before trying to animate it
        if (chair_mesh) {
          // apply rotations and translations
          chair_mesh.rotation.x = time / 10;
          chair_mesh.rotation.y = time / 5;
          // Set position directly
          chair_mesh.position.y = Math.sin(time) * 0.6;
        }
        // Render the scene
        renderer.render(scene, camera);
      }

      // Start the animation loop!
      animate();
    </script>
  </body>
</html>
