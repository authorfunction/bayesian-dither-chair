<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>threejs-bayesian-generation</title>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js Generative Shader</title>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body>
    <!-- The canvas element where the shader will be rendered -->
    <canvas id="shader-canvas"></canvas>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>

    <script>
      async function main() {
        //globals
        let isGlitchActive = true;
        let currentIndex = 0;
        let isPaused = false;
        let glitchPauseBypass = false;

        try {
          // --- setup code ---
          const canvas = document.getElementById("shader-canvas");
          const scene = new THREE.Scene();
          const clock = new THREE.Clock();
          const frustumHeight = 2;
          const aspect = canvas.clientWidth / canvas.clientHeight;
          const frustumWidth = frustumHeight * aspect;
          const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 1000);
          camera.position.z = 2;
          const renderer = new THREE.WebGLRenderer({ canvas: canvas });
          const composer = new THREE.EffectComposer(renderer);
          const renderPass = new THREE.RenderPass(scene, camera);
          composer.addPass(renderPass);

          const uniforms = {
            tDiffuse: { value: null },
            u_time: { value: 0.0 },
            u_resolution: { value: new THREE.Vector2(1, 1) },
            u_texture: { value: null },
            u_behaviour: { value: 3.0 }, // 0.0, 1.0, or 3.0 sets the behaviour of the shader
            u_baseColor: { value: new THREE.Color(0xffffff) }, // <-- ADD THIS LINE
            u_useColorBlend: { value: 0.0 },
            u_applyPattern_r: { value: 1.0 },
            u_applyPattern_g: { value: 1.0 },
            u_applyPattern_b: { value: 1.0 },
            u_applyDisplacement: { value: 1.0 },
          };
          let chair_mesh;

          // Asynchronously fetch shader files.
          // Promise.all waits for to finish.
          console.log("Fetching shaders...");
          const [vertexResponse, fragmentResponse, postResponse] =
            await Promise.all([
              fetch("./vertex_shader.glsl"),
              fetch("./fragment_shader_chromatic.glsl"),
              fetch("./fragment_post_chromatic.glsl"),
            ]);

          // Check if the files were found
          if (!vertexResponse.ok)
            throw new Error(
              `Failed to fetch vertex_shader.glsl: ${vertexResponse.statusText}`,
            );
          if (!fragmentResponse.ok)
            throw new Error(
              `Failed to fetch fragment_shader.glsl: ${fragmentResponse.statusText}`,
            );
          if (!postResponse.ok)
            throw new Error(
              `Failed to fetch fragment_post_chromatic.glsl: ${fragmentPostResponse.statusText}`,
            );

          // Get the text content from the loaded files
          const vertexShader = await vertexResponse.text();
          const fragmentShader = await fragmentResponse.text();
          const postFragmentShader = await postResponse.text();
          console.log("Shaders loaded successfully.");

          // DEFINE THE POST-PROCESSING SHADER OBJECT
          // We need a simple vertex shader for the screen quad.
          // We can define it right here as a string because it never changes.
          const ChromaticAberrationShader = {
            uniforms: {
              tDiffuse: { value: null }, // The screen texture
              u_time: { value: 0.0 },
            },
            // Standard vertex shader for post-processing (just renders a flat square)
            vertexShader: `
                  varying vec2 vUv;
                  void main() {
                      vUv = uv;
                      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
                  }
              `,
            // The fragment shader  loaded from the file
            fragmentShader: postFragmentShader,
          };

          // we got all shaders including postprocessing one with definition, we can now add the clean Aberration Pass
          // Add the clean Aberration Pass
          const aberrationPass = new THREE.ShaderPass(
            ChromaticAberrationShader,
          );
          composer.addPass(aberrationPass);

          // NOW create the material, since we have the shader text loaded
          const shader_material = new THREE.ShaderMaterial({
            vertexShader: vertexShader, // <-- Use the loaded text
            fragmentShader: fragmentShader, // <-- Use the loaded text
            uniforms: uniforms,
          });

          chair_mesh = await loadAndAddModel(
            "Stol.glb",
            shader_material,
            chair_mesh,
            uniforms,
          );
          chair_mesh.scale.set(0.3, 0.3, 0.3);
          scene.add(chair_mesh); // Add to scene

          // --- plane geometry code ---
          const plane_geometry = new THREE.PlaneGeometry(1, 2, 8, 8);
          const mesh = new THREE.Mesh(plane_geometry, shader_material);
          mesh.position.z = -2;
          scene.add(mesh);

          window.addEventListener("keydown", function (event) {
            // Check if the key pressed is Space (' ') or  'g' to toggle aberration pass
            if (event.key === " " || event.key === "g") {
              // Flip the boolean
              isGlitchActive = !isGlitchActive;
              console.log("Glitch Active:", isGlitchActive);
            }
            // 'c' key cycles behaviour of the fragment shader
            if (event.key === "c") {
              // step u_behaviour
              const behaviourValues = [3.0, 1.0, 0.0];
              currentIndex = (currentIndex + 1) % behaviourValues.length;
              const newValue = behaviourValues[currentIndex];
              console.log("Behaviour:", newValue);
              uniforms.u_behaviour.value = newValue;
            }
            // 'p' key toggles pause
            if (event.key === "p") {
              isPaused = !isPaused;
              if (isPaused) {
                clock.stop(); // This correctly freezes the elapsedTime
                console.log("Paused at", clock.getElapsedTime());
              } else {
                clock.oldTime = (performance || Date).now(); // Resets the "last frame" time
                clock.running = true; // Tell the clock to resume counting
                console.log("Resuming from", clock.getElapsedTime());
              }
            }
            // 'P' key toggles glitchPauseBypass
            if (event.key === "P") {
              glitchPauseBypass = !glitchPauseBypass;
              console.log("glitchPauseBypass:", glitchPauseBypass);
            }
          });

          //const behaviourValues = [3.0, 1.0, 0.0];

          // --- Your original resize handler ---
          function handleResize() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            renderer.setSize(width, height, false);

            const aspect = width / height;
            const frustumHeight = 2;
            const frustumWidth = frustumHeight * aspect;

            camera.left = frustumWidth / -2;
            camera.right = frustumWidth / 2;
            camera.top = frustumHeight / 2;
            camera.bottom = frustumHeight / -2;
            camera.updateProjectionMatrix();
          }
          window.addEventListener("resize", handleResize);
          handleResize();

          /*
           * Updated function that returns a Promise
           */
          function loadAndAddModel(modelFile, shaderMaterial, scene, uniforms) {
            // Return a new Promise
            return new Promise((resolve, reject) => {
              const loader = new THREE.GLTFLoader();
              loader.load(
                modelFile,
                function (gltf) {
                  // SUCCESS CALLBACK
                  console.log("Model loaded successfully!");
                  const mesh = gltf.scene; // Get the mesh from the loaded gltf

                  mesh.traverse(function (child) {
                    if (child.isMesh) {
                      const the_material = shaderMaterial.clone();
                      // --- Your material logic ---
                      the_material.uniforms.u_time = uniforms.u_time;
                      the_material.uniforms.u_resolution =
                        uniforms.u_resolution;
                      the_material.uniforms.u_behaviour = uniforms.u_behaviour;
                      the_material.uniforms.tDiffuse = uniforms.tDiffuse;
                      the_material.uniforms.u_texture = uniforms.u_texture;
                      the_material.uniforms.u_applyDisplacement =
                        uniforms.u_applyDisplacement;

                      let colorHex = "#33ff11";
                      the_material.uniforms.u_baseColor.value = new THREE.Color(
                        colorHex,
                      );
                      the_material.uniforms.u_applyPattern_r.value = 1.0;
                      the_material.uniforms.u_applyPattern_g.value = 1.0;
                      the_material.uniforms.u_applyPattern_b.value = 1.0;
                      child.material = the_material;
                    }
                  });

                  // Resolve the promise with the loaded mesh
                  resolve(mesh);
                },
                function (xhr) {
                  // PROGRESS CALLBACK
                  console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
                },
                function (error) {
                  // ERROR CALLBACK
                  console.error(
                    "An error happened while loading the model:",
                    error,
                  );
                  // Reject the promise with the error
                  reject(error);
                },
              );
            });
          }

          // --- Your original animation loop ---
          function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            uniforms.u_time.value = time;

            if (chair_mesh) {
              chair_mesh.rotation.x = time / 10;
              chair_mesh.rotation.y = time / 5;
              chair_mesh.position.y = Math.sin(time) * 0.6;
            }

            // Update time
            if (glitchPauseBypass) {
              aberrationPass.uniforms.u_time.value = performance.now() / 1000;
            } else {
              aberrationPass.uniforms.u_time.value = time;
            }

            if (isGlitchActive) {
              // EITHER RENDER WITH COMPOSER EFFECT PASS:
              composer.render();
            } else {
              // OR WITHOUT:
              renderer.render(scene, camera);
            }
          }

          // --- Start the animation loop ---
          animate();
        } catch (error) {
          // This will catch any errors, like missing files
          console.error("An error occurred:", error);
        }
      }

      // --- Call the main function to start everything ---
      main();
    </script>
  </body>
</html>
