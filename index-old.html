<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8">
    <title>threejs-bayesian-generation</title>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Generative Shader</title>
<link rel="stylesheet" href="./style.css">

  </head>

  <body>
  <body>
    <!-- The canvas element where the shader will be rendered -->
    <canvas id="shader-canvas"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script id="vertexShader-passthrough" type="x-shader/x-vertex">
        // 'varying' means it passes data to the fragment shader
        varying vec2 vUv;
        uniform sampler2D u_texture; // <-- 1. Declare the new uniform

        void main() {
            // 'uv' is an attribute provided by PlaneGeometry
            vUv = uv;

            // 'position' is an attribute.
            // 'projectionMatrix' and 'modelViewMatrix' are uniforms
            // automatically provided by three.js to position the vertex.
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
      <script id="vertexShader" type="x-shader/x-vertex">
        precision mediump float;
        // 'varying' means it passes data to the fragment shader
        varying vec2 vUv;
        uniform sampler2D u_texture; // <-- 1. Declare the new uniform
        uniform float u_time;

        void main() {
            // 'uv' is an attribute provided by PlaneGeometry
            vUv = uv;
            vec3 displacedPosition = position;
            // 2. Calculate displacement.
            // We use position.x and position.y to make the wave vary across
            // the plane, otherwise the whole plane would just move up and down.
            // Multiplying by 5.0 increases the frequency (more waves).
            // Multiplying by 0.2 decreases the amplitude (smaller waves).
            float displacement =
                sin(position.x * 5.0 + u_time) * 0.2 +
                sin(position.y * 5.0 + u_time) * 0.2;

            // 3. Apply the displacement to the z-axis
            //displacedPosition.z = displacement; // This displacement will be invisible in orthogrpahic straight down view
            // 3. Apply the displacement to the x-axis instead
            displacedPosition.x = position.x + displacement;

          gl_Position = projectionMatrix * modelViewMatrix * vec4(displacedPosition, 1.0);
        }
    </script>

    <!-- 3. The Fragment Shader (GLSL) -->
    <!--
      This is where the generative art happens!
      It runs for EVERY pixel on the plane.
    -->
    <script id="fragmentShader" type="x-shader/x-fragment">
        // Set default precision for floating point numbers
        precision mediump float;

        // Uniforms are variables passed from our JavaScript
        uniform vec2 u_resolution; // The resolution of the canvas
        uniform float u_time;       // The elapsed time for animation
        uniform sampler2D u_texture; // <-- 1. Declare the new uniform

        // 'vUv' is the data received from the vertex shader (0.0 to 1.0)
        varying vec2 vUv;

        // --- BAYER DITHERING MAP ---
        // We define the 4x4 Bayer threshold map as a matrix.
        // GLSL matrices are "column-major", so we list the columns.
        const mat4 bayerMap = mat4(
            15.0, 195.0, 60.0, 240.0,  // Column 0
            135.0, 75.0, 180.0, 120.0, // Column 1
            45.0, 225.0, 30.0, 210.0,  // Column 2
            165.0, 105.0, 150.0, 90.0   // Column 3
        );
        // --- END DITHERING MAP ---

      vec3 createColorPattern(vec2 st, float time) {
          float r = sin(st.x * 10.0 + time * 0.5) * 0.5 + 0.5;
          float g = sin(st.y * 10.0 + time * 0.3) * 0.5 + 0.5;
          float b = sin(st.x * 5.0 - st.y * 5.0 + time) * 0.5 + 0.5;
          return vec3(r, g, b);
      }

      float bayesianDither(vec3 originalColor) {
        // 2. CALCULATE LUMINANCE (0.0 to 1.0)
        // Convert the color to grayscale brightness
        //originalColor = color;
        float luminance = dot(originalColor, vec3(0.299, 0.587, 0.114));

        // 3. GET DITHER THRESHOLD
        // gl_FragCoord.xy gives us the screen pixel coordinate (e.g., 800, 600)
        // We use mod() to find which cell in the 4x4 map this pixel corresponds to.
        int x = int(mod(gl_FragCoord.x, 4.0));
        int y = int(mod(gl_FragCoord.y, 4.0));

        // Look up the threshold value from the map (col, row)
        // The value is 0-255, so we divide by 255.0 to normalize it to 0.0-1.0
        float threshold = bayerMap[x][y] / 255.0;

        // 4. COMPARE AND SET FINAL COLOR
        // If the luminance is brighter than the threshold, use 1.0 (bright).
        // Otherwise, use 0.0 (dark).
        float ditheredValue = luminance > threshold ? 1.0 : 0.0;

        return ditheredValue;
        //return 1.0;
      }

        void main() {
            // 'vUv' gives us the normalized coordinate (0.0 to 1.0)
            vec2 st = vUv;

            // 1. CALCULATE ORIGINAL COLOR
            vec3 originalColor = createColorPattern(st, u_time);
            vec3 textureColor = texture2D(u_texture, st).rgb;

            vec3 blendedColor = mix(originalColor, textureColor, 0.5);
            // 2. Apply Bayesian dither
            float ditheredValue = bayesianDither(blendedColor);
            //float ditheredTextureValue = bayesianDither(textureColor);

            // Blend the original color with the dithered value.
            // This preserves the color, but applies the dither pattern
            // (multiplying by 1.0 keeps the color, multiplying by 0.0 makes it black).
            // with texture:
            //vec3 finalColor = blendedColor * ditheredValue;

            // to skip texture:
            float ditheredValue2 = bayesianDither(originalColor);
            vec3 finalColor = originalColor * ditheredValue2;

            // Set the final composited color as periodically bw or colored
            if ((sin(u_time/1.17)) < 0.0 ) {
              gl_FragColor = vec4(finalColor, 1.0); //<= Colorize
            }
            else {
              gl_FragColor = vec4(vec3(ditheredValue2), 1.0);
            }; //<= Monochrome no texture
            //gl_FragColor = vec4(vec3(ditheredValue), 1.0); //<= Monochrome w/ texture
        }

    </script>

    <!-- 4. The JavaScript to set up three.js -->
    <script>
        // Get the canvas element
        const canvas = document.getElementById('shader-canvas');

        // Create the three.js scene
        const scene = new THREE.Scene();

        // Create a clock to track elapsed time
        const clock = new THREE.Clock();

        // Create a camera. For a 2D shader plane, an OrthographicCamera is best
        // as it has no perspective.
        const camera = new THREE.OrthographicCamera(
            -1, // left
             1, // right
             1, // top
            -1, // bottom
            -1, // near
             1  // far
        );
        // Instead of the default position, move the camera
        // camera.position.set(1, 1, 1); // Or any non-zero x, y, z
        // camera.lookAt(0, 0, 0); // centre

        // Create the WebGL renderer
        const renderer = new THREE.WebGLRenderer({ canvas: canvas });
        renderer.setSize(window.innerWidth, window.innerHeight);

        const uniforms = {
            u_time: { value: 0.0 },
            u_resolution: { value: new THREE.Vector2(10, 10) },
            u_texture: { value: null } // Start as null
        };

        // 1. Instantiate the loader
        const loader = new THREE.GLTFLoader();

        // 2. Call the .load() method
        loader.load(
            // Resource URL
            'Stol.glb',

            // 3. (onLoad) Success callback
            // This function runs when the model has finished loading
            function ( gltf ) {
                // gltf.scene is the group containing the model's meshes
                // You can add it directly to your scene
                scene.add( gltf.scene );

                // You can also access animations, cameras, etc. from the gltf object
                // For example: const animations = gltf.animations;
            },

            // 4. (onProgress) Optional progress callback
            // This function runs while the model is loading
            function ( xhr ) {
                console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
            },

            // 5. (onError) Optional error callback
            // This function runs if there's an error loading the model
            function ( error ) {
                console.error( 'An error happened while loading the model:', error );
            }
        );

        // Create the geometry: a simple plane that fills the screen
        // The 2, 2 dimensions match the orthographic camera's view
        const plane_geometry = new THREE.PlaneGeometry(2, 2, 8, 8);

        // Create the material, using our custom shaders and uniforms
        const material = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent,
            uniforms: uniforms
        });

        // Create a mesh (the 3D object) from the geometry and material
        const mesh = new THREE.Mesh(plane_geometry, material);

        // Add the mesh to the scene
        scene.add(mesh);

        const sphere_geometry = new THREE.SphereGeometry(0.5,8,8);
        const sphere_material = new THREE.MeshNormalMaterial();
        const sphere_mesh = new THREE.Mesh( sphere_geometry, material );
        scene.add( sphere_mesh );

        // Handle window resizing -- JUST REMOVE THIS BLOCK TO AVOID STRETCHING
        /*window.addEventListener('resize', () => {
            // Update renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
            // Update shader resolution uniform
            uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);

        });*/

        // Create the animation loop
        function animate() {
            // Request the next frame
            requestAnimationFrame(animate);
            time = clock.getElapsedTime()

            // Update the 'u_time' uniform with the elapsed time
            uniforms.u_time.value = time;
            // apply rotations and translations
            sphere_mesh.rotation.x = time / 10;
            sphere_mesh.rotation.y = time / 5;
            sphere_mesh.translate.y = time * -10;
            sphere_mesh.position.set(0, Math.sin(time)*0.6 , 0);


            // Render the scene
            renderer.render(scene, camera);
        }

        // Start the animation loop!
        animate();
    </script>
</body>
</html>

  </body>

</html>
